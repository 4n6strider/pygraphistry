#!/usr/bin/env bash

########
# This script kicks off a small web server in order to test out the site running
# in the browser. If $WEBKITWEBCL_PATH is set in your environment to the path of
# WebKit.app, or can be set by sourcing ~/.webkitwebcl, then we also run the
# special WebKit WebCL browser, disable its caches, and direct it to the local
# server. We re-open this app every time we quit (to faciliate the common
# pattern of restarting your browser when testing code) until Ctrl+C is sent to
# this script in the terminal.
########


# TODO: Do we want to `cd` to the location of this script before serving files,
# or stay in the same directory to allow us to serve different directories?

# TODO: If we can't find $WEBKITWEBCL_PATH, pop open an AppleScript dialog
# box to choose it, and write the output to $WEBKITWEBCL_PATH

# TODO: We should periodically check the position of the WebKit.app window and
# re-record its position. This will allow us to launch subsequent WebKit windows
# in the same location, even if the user changes the location after launch.
# (Presently, we only record position on launch and restore that position when
# launching subsequent WebKit windows.)


server_port="8888"
server_addr="127.0.0.1"


if [[ $1 == "-h" ]] || [[ $1 == "--help" ]]; then
	echo "Usage: $(basename "$0") [--dev] [-h|--help]"
	echo "Run a web server on http://localhost:8888 and open WebKit.app to it, so we can"
	echo "test our WebCL code."
	echo
	echo "Options:"
	echo "  --dev        Run in development mode (open the Web Inspector automatically,"
	echo "               and continually re-launch WebKit.app when it exits)"
	echo "  -h, --help   Show this help message and exit"
	exit 0
fi

if [[ $1 == "--dev" ]]; then
	dev_mode=1
else
	dev_mode=''
fi


# Output message colors
message_color="$(tput bold)$(tput setab 6)"
quit_color="$(tput bold)$(tput setab 1)"
reset_color="$(tput sgr0)"


# If $WEBKITWEBCL_PATH isn't set, and ~/.superconductorrc exists, source it and
# then check if $WEBKITWEBCL_PATH exists again
if [ -z $WEBKITWEBCL_PATH ] && [ -e ~/.webkitwebcl ]; then
	. ~/.webkitwebcl
fi
if [ -z  $WEBKITWEBCL_PATH ]; then
	printf '\n%sCould not find WebKit WebCL app. Not launching app; just running server.%s\n\n' "$quit_color" "$reset_color"
	printf '%sTo change this, set the $WEBKITWEBCL_PATH variable in your environment, or in%s\n' "$quit_color" "$reset_color"
	printf '%s~/.webkitwebcl.%s\n\n' "$quit_color" "$reset_color"

	${server}
	exit
fi

webkit_path="$WEBKITWEBCL_PATH"



# Run the server in the background, but save its PID so we can kill it when this script exits
echo "$(cat <<PYTHONSCRIPT
from __future__ import print_function
import sys

if sys.version_info[0] <= 2:
    import SimpleHTTPServer, BaseHTTPServer
    HandlerClass = SimpleHTTPServer.SimpleHTTPRequestHandler
    ServerClass = BaseHTTPServer.HTTPServer
else: # Python >= 3
    import http.server
    HandlerClass = http.server.SimpleHTTPRequestHandler
    ServerClass = http.server.HTTPServer

server_address = ("${server_addr}", ${server_port})

HandlerClass.protocol_version = "HTTP/1.0"
httpd = ServerClass(server_address, HandlerClass)
sa = httpd.socket.getsockname()
print("Serving HTTP on", sa[0], "port", sa[1], "...\n")

try:
    httpd.serve_forever()
except KeyboardInterrupt:
    print("\nKeyboard interrupt received, exiting.")
    httpd.server_close()
    sys.exit(0)

PYTHONSCRIPT
)" | python &

server_pid="$!"



# Tell WebKit WebCL to not save/restore window on exit/launch
defaults write org.webkit.nightly.WebKit ApplePersistenceIgnoreState 0

# The TTY of the terminal that spawned this script, so that we can activate
# the terminal window/tab (identified by TTY) later
spawning_tty="$(tty)"
safari_window_bounds=''

# The AppleScript to launch WebKit WebCL, disable its caches, and open the page to the local server
launch_script=$(cat <<APPLESCRIPT
on run argv
	-- The bounds of the last Safari script may be passed as the first argument
	-- on the command line
	if length of argv > 0
		-- Split argv into a list with ',' as the seperator (if argv[0] is
		-- empty, it will turn into a 0-length list, which is fine.)
		set AppleScript's text item delimiters to ", "
		set oldBounds to (text items of (item 1 of argv))
	else
		set oldBounds to {}
	end if

	-- Activate the terminal window containing the tab running this script. This
	-- will (hopfully) activate the Desktop that the Terminal window containing
	-- that tab is running in.
	-- This is not sufficient to launch WebKit in the same desktop as it in
	-- multi-monitor setups, since OS X will still happily launch WebKit in
	-- the other monitor (since it sees it as all one desktop.) For that, we
	-- need to set the window bounds,
	tell application "Terminal"
		repeat with win in windows
			repeat with curTab in (tabs in win)
				if tty in curTab is "${spawning_tty}" then
					activate
					activate win
					set frontmost of win to true
				end if
			end repeat -- /tabs
		end repeat -- /windows
	end tell

	tell application "$webkit_path" to activate

	tell application "System Events"
		tell process "WebKit"
			tell menu "Develop" of menu bar 1
				click menu item "Empty Caches"
				-- If "Disable Caches" isn't already checked, click it
				if (value of attribute "AXMenuItemMarkChar" of menu item "Disable Caches") ≠ "✓" then
					click menu item "Disable Caches"
				end if
			end tell
		end tell
	end tell

	tell application "$webkit_path"
		tell window 1
			-- If we know the bounds of the WebKit window from the last time we
			-- launched it, move the new window to that position
			if length of oldBounds >= 2
				-- Calculate the current width and height
				set curBounds to bounds
				set curWidth to (item 3 of curBounds) - (item 1 of curBounds)
				set curHeight to (item 4 of curBounds) - (item 2 of curBounds)

				-- Calculate the new width and height by placing the upper-left
				-- corner in the old position, and the lower-right corner in
				-- a position so that the width and height are equal to the
				-- current width and height
				set newBounds to {item 1 of oldBounds, item 2 of oldBounds, ((item 1 of oldBounds) + curWidth), ((item 2 of oldBounds) + curHeight)}

				set bounds to newBounds
			end if
			set webkitBounds to bounds

			set URL of current tab to "http://${server_addr}:${server_port}" --:${server_port}
		end tell
	end tell

	if "${dev_mode}" equals "1"
		tell application "System Events"
			-- set SafariCL to application process "WebKit"
			-- set frontmost of SafariCL to true
			tell process "WebKit"
				tell menu "Develop" of menu bar 1
					if (exists menu item "Show Web Inspector")
						-- We also tried checking and if
						-- (value of attribute "AXEnabled" of menu item "Show Web Inspector")
						-- is true, to make sure we're able to click the menu
						-- item, but it seemed to be always false, and its
						-- falseness didn't seem to impede clicking it.
						click menu item "Show Web Inspector"
					end if -- /menu exists
				end tell
			end tell
		end tell
	end if

	return webkitBounds
end run

APPLESCRIPT
)


# The AppleScript to quit WebKit WebCL (called when this script exits)
quit_script=$(cat <<APPLESCRIPT
	tell application "$webkit_path"
		if it is running then
			quit
		end if
	end tell
APPLESCRIPT
)


# The code to run when we exit (either by pressing Ctrl+C, or other means)
trapped() {
	printf "\n\n%sExiting...%s\n" "$quit_color" "$reset_color"
	echo "$quit_script" | osascript -
	if [[ $server_pid ]]; then
		kill $server_pid 2>/dev/null
	fi

	exit
}

if [[ $dev_mode ]]; then
	# Infinitely re-launch WebKit WebCL, until Ctrl+C is called
	while :
	do
		# Run the "launch WebKit" AppleScript, passing $safari_window_bounds as the
		# first argument, and saving the return value of the script as the new
		# $safari_window_bounds.
		safari_window_bounds=$(echo "$launch_script" | osascript - "${safari_window_bounds}")
		trap trapped SIGINT
		open -W -a "$webkit_path" >/dev/null

		printf "\n%sRelaunching Safari. Press Ctrl+C to stop.%s\n\n" "$message_color" "$reset_color"
	done
else
	echo "$launch_script" | osascript - >/dev/null
	trap trapped SIGINT
	open -W -a "$webkit_path" >/dev/null
fi

trapped
