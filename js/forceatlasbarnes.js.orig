'use strict';

var debug = require("debug")("graphistry:graph-viz:cl:forceatlas2barnes"),
    _     = require('underscore'),
    cljs  = require('./cl.js'),
    Q     = require('q'),
    util  = require('./util.js'),
    LayoutAlgo = require('./layoutAlgo.js'),
    Kernel = require('./kernel.js'),
    BarnesKernelSeq = require('./javascript_kernels/barnesKernelSeq.js'),
    EdgeKernelSeqFast = require('./javascript_kernels/edgeKernelSeqFast.js'),
    faSwingsKernel = require('./javascript_kernels/faSwingsKernel.js'),
    integrate1Kernel = require('./javascript_kernels/integrate1Kernel.js'),
    integrate2Kernel = require('./javascript_kernels/integrate2Kernel.js'),
    integrate3Kernel = require('./javascript_kernels/integrate3Kernel.js');


function getNumWorkitemsByHardware(deviceProps, workGroupSize) {
    var numWorkGroups = {
        toBarnesLayout: 30,
        boundBox: 30,
        buildTree: 30,
        computeSums: 10,
        sort: 16,
        calculateForces: 60
    }

    // console.log("DEVICE NAME: ", deviceProps.DEVICE_NAME);
    if (deviceProps.DEVICE_NAME.indexOf('GeForce GT 650M') != -1) {
        numWorkGroups.buildTree = 1;
        numWorkGroups.computeSums = 1;

    } else if (deviceProps.DEVICE_NAME.indexOf('Iris Pro') != -1) {
        numWorkGroups.computeSums = 6;
        numWorkGroups.sort = 8;
    } else if (deviceProps.DEVICE_NAME.indexOf('HD Graphics 4000') != -1) {
        throw new Error('Unsupported device config: ' + deviceProps.DEVICE_NAME);
    }

    return _.mapObject(numWorkGroups, function(val, key) {
        return workGroupSize * val;
    });
}


function ForceAtlas2Barnes(clContext) {
    LayoutAlgo.call(this, 'ForceAtlasBarnes');

    debug('Creating ForceAtlasBarnes kernels');
    this.barnesKernelSeq = new BarnesKernelSeq(clContext);

    this.edgeKernelSeq = new EdgeKernelSeqFast(clContext);

    this.faSwingsKernel = new faSwingsKernel(clContext);

    this.integrate1Kernel = new integrate1Kernel(clContext);

    this.integrate2Kernel = new integrate2Kernel(clContext);

    this.integrate3Kernel = new integrate3Kernel(clContext);

    this.kernels = this.kernels.concat([this.barnesKernelSeq.toBarnesLayout, this.barnesKernelSeq.boundBox,
                                        this.barnesKernelSeq.buildTree, this.barnesKernelSeq.computeSums,
                                        this.barnesKernelSeq.sort, this.barnesKernelSeq.calculateForces,
                                        this.edgeKernelSeq.mapEdges, this.edgeKernelSeq.segReduce, this.faSwingsKernel.faSwings,
                                        this.integrate1Kernel.faIntegrate, this.integrate2Kernel.faIntegrate2,
                                        this.integrate3Kernel.faIntegrate3]);
}

ForceAtlas2Barnes.prototype = Object.create(LayoutAlgo.prototype);
ForceAtlas2Barnes.prototype.constructor = ForceAtlas2Barnes;

<<<<<<< HEAD
ForceAtlas2Barnes.argsToBarnesLayout = [
    'scalingRatio', 'gravity', 'edgeInfluence', 'flags', 'numPoints',
    'inputPositions', 'xCoords', 'yCoords', 'mass', 'blocked', 'maxDepth',
    'pointDegrees', 'stepNumber', 'WARPSIZE'
];

// All BarnesHut Kernels have the same arguements
ForceAtlas2Barnes.argsBarnes = ['scalingRatio', 'gravity', 'edgeInfluence', 'flags', 'xCoords',
                          'yCoords', 'accX', 'accY', 'children', 'mass', 'start',
                          'sort', 'globalXMin', 'globalXMax', 'globalYMin', 'globalYMax', 'swings', 'tractions',
                          'count', 'blocked', 'step', 'bottom', 'maxDepth', 'radius', 'globalSpeed', 'stepNumber',
                          'width', 'height', 'numBodies', 'numNodes', 'pointForces', 'tau', 'WARPSIZE'];

ForceAtlas2Barnes.argsEdges = [
    'scalingRatio', 'gravity', 'edgeInfluence', 'flags', 'edges',
    'workList', 'inputPoints', 'partialForces', 'stepNumber', 'numWorkItems', 'outputForces'
];

ForceAtlas2Barnes.argsSwings = ['prevForces', 'curForces', 'swings' , 'tractions'];

ForceAtlas2Barnes.argsIntegrate = [
    'gSpeed', 'inputPositions', 'curForces', 'swings', 'outputPositions'
];

ForceAtlas2Barnes.argsIntegrate2 = [
    'numPoints', 'tau', 'inputPositions', 'pointDegrees', 'curForces', 'swings',
    'tractions', 'outputPositions'
];

ForceAtlas2Barnes.argsIntegrate3 = [
    'globalSpeed', 'inputPositions', 'curForces', 'swings', 'outputPositions'
];


ForceAtlas2Barnes.argsType = {
    scalingRatio: cljs.types.float_t,
    gravity: cljs.types.float_t,
    edgeInfluence: cljs.types.uint_t,
    flags: cljs.types.uint_t,
    numPoints: cljs.types.uint_t,
    tilesPerIteration: cljs.types.uint_t,
    tilePointsParam: cljs.types.local_t,
    tilePointsParam2: cljs.types.local_t,
    inputPositions: null,
    pointForces: null,
    partialForces: null,
    outputForces: null,
    outputPositions: null,
    width: cljs.types.float_t,
    height: cljs.types.float_t,
    stepNumber: cljs.types.uint_t,
    pointDegrees: null,
    edges: null,
    workList: null,
    inputPoints: null,
    outputPoints: null,
    curForces: null,
    prevForces: null,
    swings: null,
    tractions: null,
    gSpeeds: null,
    tau: cljs.types.float_t,
    gSpeed: cljs.types.float_t,
    springs: null,
    xCoords: null,
    yCoords: null,
    accX: null,
    accY: null,
    children: null,
    mass: null,
    start: null,
    sort: null,
    globalXMin: null,
    globalXMax: null,
    globalYMin: null,
    globalYMax: null,
    count: null,
    blocked: null,
    step: null,
    bottom: null,
    maxDepth: null,
    radius: null,
    numBodies: cljs.types.uint_t,
    numNodes: cljs.types.uint_t,
    numWorkItems: cljs.types.uint_t,
    globalSpeed: null,
    WARPSIZE: cljs.types.define
}
=======
>>>>>>> dev/seg-reduce

ForceAtlas2Barnes.prototype.setPhysics = function(cfg) {
    LayoutAlgo.prototype.setPhysics.call(this, cfg)

    var mask = 0;
    var flags = ['preventOverlap', 'strongGravity', 'dissuadeHubs', 'linLog'];
    flags.forEach(function (flag, i) {
        var isOn = cfg.hasOwnProperty(flag) ? cfg[flag] : false;
        if (isOn) {
            mask = mask | (1 << i);
        }
    });

    this.barnesKernelSeq.setPhysics(cfg, mask);
    this.edgeKernelSeq.setPhysics(cfg, mask);
}

// Contains any temporary buffers needed for layout
var tempLayoutBuffers  = {
  globalSpeed: null
};

// Create temporary buffers needed for layout
var setupTempLayoutBuffers = function(simulator) {
    return Q.all(
        [
        simulator.cl.createBuffer(Float32Array.BYTES_PER_ELEMENT, 'global_speed')
        ])
    .spread(function (globalSpeed) {
      tempLayoutBuffers.globalSpeed = globalSpeed;
      return tempLayoutBuffers;
    })
    .catch(function(error) {
      console.log(error);
    });
};


ForceAtlas2Barnes.prototype.setEdges = function(simulator) {
    var localPosSize =
            Math.min(simulator.cl.maxThreads, simulator.numMidPoints)
            * simulator.elementsPerPoint
            * Float32Array.BYTES_PER_ELEMENT;

    var that = this;

<<<<<<< HEAD
    var vendor = simulator.cl.deviceProps.DEVICE_VENDOR.toLowerCase();
    var warpsize = 1; // Always correct
    if (vendor.indexOf('intel') != -1) {
        warpsize = 16;
    } else if (vendor.indexOf('nvidia') != -1) {
        warpsize = 32;
    } else if (vendor.indexOf('amd') != -1) {
        warpsize = 64;
    }

    return setupTempBuffers(simulator).then(function (tempBuffers) {

        that.toBarnesLayout.set({xCoords: tempBuffers.x_cords.buffer,
          yCoords:tempBuffers.y_cords.buffer, mass:tempBuffers.mass.buffer,
                            blocked:tempBuffers.blocked.buffer, maxDepth:tempBuffers.maxdepth.buffer,
                            numPoints:simulator.numPoints,
                            inputPositions: simulator.buffers.curPoints.buffer,
                            pointDegrees: simulator.buffers.degrees.buffer,
                            WARPSIZE: warpsize});

        function setBarnesKernelArgs(kernel, buffers) {
            //console.log(buffers);
            kernel.set({xCoords:buffers.x_cords.buffer,
                        yCoords:buffers.y_cords.buffer,
                        accX:buffers.accx.buffer,
                        accY:buffers.accy.buffer,
                        children:buffers.children.buffer,
                        mass:buffers.mass.buffer,
                        start:buffers.start.buffer,
                        sort:buffers.sort.buffer,
                        globalXMin:buffers.xmin.buffer,
                        globalXMax:buffers.xmax.buffer,
                        globalYMin:buffers.ymin.buffer,
                        globalYMax:buffers.ymax.buffer,
                        swings:simulator.buffers.swings.buffer,
                        tractions:simulator.buffers.tractions.buffer,
                        count:buffers.count.buffer,
                        blocked:buffers.blocked.buffer,
                        bottom:buffers.bottom.buffer,
                        step:buffers.step.buffer,
                        maxDepth:buffers.maxdepth.buffer,
                        radius:buffers.radius.buffer,
                        globalSpeed: buffers.globalSpeed.buffer,
                        width:simulator.dimensions[0],
                        height:simulator.dimensions[1],
                        numBodies:buffers.numBodies,
                        numNodes:buffers.numNodes,
                        pointForces:simulator.buffers.partialForces1.buffer,
                        WARPSIZE: warpsize});
        };
        setBarnesKernelArgs(that.boundBox, tempBuffers);
        setBarnesKernelArgs(that.buildTree, tempBuffers);
        setBarnesKernelArgs(that.computeSums, tempBuffers);
        setBarnesKernelArgs(that.sort, tempBuffers);
        setBarnesKernelArgs(that.calculateForces, tempBuffers);
    });
}

function pointForces(simulator, toBarnesLayout, boundBox, buildTree,
    computeSums, sort, calculateForces, stepNumber) {
    var resources = [
        simulator.buffers.curPoints,
        simulator.buffers.forwardsDegrees,
        simulator.buffers.backwardsDegrees,
        simulator.buffers.partialForces1
    ];

    toBarnesLayout.set({stepNumber: stepNumber});
    boundBox.set({stepNumber: stepNumber});
    buildTree.set({stepNumber: stepNumber});
    computeSums.set({stepNumber: stepNumber});
    sort.set({stepNumber: stepNumber});
    calculateForces.set({stepNumber: stepNumber});


    simulator.tickBuffers(['partialForces1']);

    debug("Running Force Atlas2 with BarnesHut Kernels");

    // For all calls, we must have the # work items be a multiple of the workgroup size.
    // Above each call, I listed some benchmarks for numbers of workgroups
    // (numWorkItems = numWorkGroups * workGroupSize).
    // These are measured in ms on staging for NetflowHuge.
    // Lower these values if it's crashing on your local macbook.

    // If one is commented out, it's ideal for server but won't run locally
    // It's replaced by default with a very similar performance setting
    // that runs locally.

    var workGroupSize = 256;
    var workItems = getNumWorkitemsByHardware(simulator.cl.deviceProps, workGroupSize);

    return toBarnesLayout.exec([workItems.toBarnesLayout], resources, [workGroupSize])

    .then(function () {
      simulator.cl.queue.finish();
    })

    .then(function () {
      return boundBox.exec([workItems.boundBox], resources, [workGroupSize]);
    })

    // 4:49, 10:38, 20:31, 30:30, 40:31, 60:43
    .then(function () {
      return buildTree.exec([workItems.buildTree], resources, [workGroupSize]);
    })

    // 4:21, 10:14, 20:13, 30:13, 40:14, 60:18
    .then(function () {
      // return computeSums.exec([20*256], resources, [256]);
      return computeSums.exec([workItems.computeSums], resources, [workGroupSize]);
    })

    // 4:16, 10:10, 20:8, 30:8, 40:9, 60:13,
    .then(function () {
      // return sort.exec([30*256], resources, [256]);
      return sort.exec([workItems.sort], resources, [workGroupSize]);
    })

    // 60:42, 70:62, 80:57, 100:48, 120:42, 140:49, 160:45,
    // 200:45, 240:41, 280:43, 320:41, 360:41, 400:42
    .then(function () {
      // return calculateForces.exec([120*256], resources, [256]);
      return calculateForces.exec([workItems.calculateForces], resources, [workGroupSize]);
    })

=======
    return setupTempLayoutBuffers(simulator).then(function (layoutBuffers) {
      that.barnesKernelSeq.setEdges(simulator, layoutBuffers);
      that.edgeKernelSeq.setEdges(simulator, layoutBuffers);

    });
}

function pointForces(simulator, barnesKernelSeq, stepNumber) {
     return barnesKernelSeq.execKernels(simulator, stepNumber)
>>>>>>> dev/seg-reduce
    .fail(function (err) {
        console.error('Computing pointForces failed', err, (err||{}).stack);
    });
}


function edgeForces(simulator, edgeKernelSeq, stepNumber) {
    var buffers = simulator.buffers;
     return edgeKernelSeq.execKernels(simulator, buffers.forwardsEdges, buffers.forwardsWorkItems,
                                      simulator.numForwardsWorkItems, buffers.backwardsEdges, buffers.backwardsWorkItems,
                                      simulator.numBackwardsWorkItems, buffers.curPoints, stepNumber);
}



ForceAtlas2Barnes.prototype.tick = function(simulator, stepNumber) {
    var that = this;
    var tickTime = Date.now();
    return that.barnesKernelSeq.execKernels(simulator, stepNumber)
    .then(function () {
       return edgeForces(simulator, that.edgeKernelSeq, stepNumber);
    }).then(function () {
        return that.faSwingsKernel.execKernels(simulator);
    }).then(function () {
        // return integrate(simulator, that.faIntegrate);
        // return integrate2(simulator, that.faIntegrate2);
        return that.integrate3Kernel.execKernels(simulator, tempLayoutBuffers);
        //return integrate3(simulator, that.faIntegrate3);
    }).then(function () {
        var buffers = simulator.buffers;
        simulator.tickBuffers(['curPoints']);
        return Q.all([
            buffers.nextPoints.copyInto(buffers.curPoints),
            buffers.curForces.copyInto(buffers.prevForces)
        ]);
    }).then(function () {
        return simulator;
    });
}


module.exports = ForceAtlas2Barnes;
